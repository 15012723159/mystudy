# 接口
接口是一种能力

1：接口的命名规则与类型不同。如果修饰符是public。则该接口在整个项目中可见 ，如果省略修饰符 则该接口只能在该包可见

2：接口中可以定义常量，不能定义变量，接口中的属性都会自动用public static final修饰，即接口中的属性都是全局静态常量，接口中的常量必须在定义时指定初始值

3：接口中所有的方法抽象方法。接口中的方法都会自动用public abstract修饰。即接口中只有全局抽象方法，

4：和抽象类一样，接口不能被实例化，接口中不能有狗构造方法

5：接口之间可以通过extends 实现继承关系，一个接口可以继承多个接口。但接口不能继承类

6：接口的实现类必须实现接口的全部方法，否则必须定义为抽象类

7：一个类只能有一个直接父类，但可以通过implements实现多个接口，当雷在继承父类的同时有实现了多个接口时，extends关键字必须位于implements关键字之前

**接口的注意事项：**

01.接口不能实例化，因为接口是比抽象类抽象程度更高的类型  
02一个类如果实现了某个接口，必须重写该接口中的所有方法  
03.接口不能有构造，但是抽象类可以有  
04.接口中所有方法都公有的抽象方法  
05.接口中的所有字段必须都是公有的静态常量  
06.接口本身也是一种数据类型  
07.接口只是为实现它的类定义了规范，保证实现类方法签名和接口中对应方法一致。  
08.通过接口可以实现多继承  
09.一个借口中最好只定义一个方法，防止接口污染

**java中接口的特点：**

1. 接口中的方法，永远都被public来修饰

2. 接口中没有构造方法，也不能实例化接口对象

3. 接口中只有方法的声明，没有方法体

4. 接口中只有常量，如果定义变量，在编译的时候都会默认加上“public static final”

5. 接口中定义的方法都需要实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需要定义为抽象类

6. 静态方法不能被子类重写（覆盖），因此接口中不定声明静态方法

7. 使用接口可以实现多继承




# 抽象类
抽象类就是不能使用new方法进行实例化的类（不能被实例化，可以有多个抽象方法），即没有具体实例对象的类，抽象类有点类似于“模板”的作用,目的是根据其格式来创建和修改新的类，对象不能由抽象类直接创建，只可以通过抽象类派生出新的子类，再由其子类来创建对象，当一个类被声明为抽象类时，要在这个类前面加上修饰符abstract,在抽象类中的成员方法可以包括一般方法和抽象方法

**抽象类的关键字：abstract**

**abstract 关键字，和哪些关键字不能共存？**

final：被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。  
private: 抽象类中的私有的抽象方法，不被子类所知，就无法被复写。  
而抽象方法出现的就是需要被复写。  
static：如果static可以修饰抽象方法，那么连对象都省了，直接类名调用就可以了

**java中抽象类的特点：**

1. 如果一个类中有抽象方法，那么这个类一定是抽象类

 2. 抽象类中不一定有抽象方法

 3. 抽象类中可以存在抽象方法

 4. 抽象类中可以存在构造方法

 5. 抽象类中可以存在普通属性、方法、静态属性和静态方法

 6. 抽象类中的抽象方法需要有子类实现，如果子类不实现，则子类也需要定义为抽象的

7，抽象方法和抽象类都必须被abstract关键字修饰。

8，抽象类不可以用new创建对象。因为调用抽象方法没意义

9：抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法

**接口和抽象类的区别之处：**

1. 接口中所有的方法隐含都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法

2. 类可以实现很多个接口，但是只能继承一个抽象类

3. 类可以不实现抽象类和接口声明的所有方法，在这种情况下，类也必须得声明成是抽象的

4. 抽象类可以在不提供接口方法实现的情况下实现接口

5. java接口中声明的变量默认都是final的，抽象类可以包含非final变量

6. java接口中的成员函数默认都是public的，抽象类中的成员函数可以是private，protected或者是public的

7. 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是如果它包含main方法的话是可以被调用的

8：抽象类中可以有普通方法，接口中不能。

9：抽象类可以有构造，接口不能

10：抽象类中可以有普通字段，而接口中不行

11：抽象类不能实现多继承，接口可以

12：符合isa关系的选用抽象类，符合hasa关系的选用接口比抽象类抽象程度更高